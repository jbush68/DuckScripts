"""
Iteration 1: This is the original code for the assignment,
prior to the abusive use of itertools and list comprehensions.
"""

import random as r
import random as ra
import itertools as it


# Define blank matrix of random values
def define_matrix(rows, columns, m_type):
    if not (0 < rows < 11 and 0 < columns < 11):
        return False
    return [[r.randrange(0, 100, 2) + m_type for _ in range(columns)] for _ in range(rows)]


# Ask user for matrix data and generate matrix data
def query_matrix(m_des, m_type):
    # Create dimensions list and define rand matrix from list comprehension using user input
    dimensions = [int(num) for num in input(f'Enter matrix {m_des} rows and columns: ').split(' ')]
    q_matrix = define_matrix_flat(dimensions[0], dimensions[1], m_type)
    # Query matrix until valid dimensions provided
    if not q_matrix:
        print('Invalid matrix size. Try again.')
        query_matrix(m_des, m_type)
    else:
        print()
        return [q_matrix, dimensions[0], dimensions[1]]


# Custom print matrix function iterating over each layer of the nested loop
def print_matrix(p_matrix_in):
    for p_row in p_matrix_in:
        for p_col in p_row:
            print(f'{p_col:<6}', end='')
        print()
    print()


# Calculate the kronecker product of 2 matrices
def kronecker_matrix(k_matrix_one, k_matrix_two):
    # Define variables for dimensions of all 3 matrices
    row_one, col_one = k_matrix_one[1], k_matrix_one[2]
    row_two, col_two = k_matrix_two[1], k_matrix_two[2]
    k_rows = row_one * row_two
    k_cols = col_one * col_two

    # Generate new blank matrix
    k_matrix = [[1 for _ in range(k_cols)] for _ in range(k_rows)]

    # Kronecker product magic
    for i_row in range(row_one):
        for i_col in range(col_one):
            for b_row in range(row_two):
                for b_col in range(col_two):
                    target_row, target_col = b_row + (i_row * row_two), b_col + (i_col * col_two)
                    k_matrix[target_row][target_col] = k_matrix_one[0][i_row][i_col] * k_matrix_two[0][b_row][b_col]

    return [k_matrix, k_rows, k_cols]


# Return the transpose of a matrix
def transpose_matrix(t_matrix_in):
    # Define variables and new transposed matrix
    in_row, in_col = t_matrix_in[1], t_matrix_in[2]
    t_matrix_out = [[0 for _ in range(in_row)] for _ in range(in_col)]

    # Write transposed matrix using input matrix
    for row in range(in_row):
        for col in range(in_col):
            t_matrix_out[col][row] = t_matrix_in[0][row][col]

    return [t_matrix_out, in_col, in_row]


# Calculate the barcode generated by a random matrix
def matrix_barcode(b_matrix_in):
    return ' '.join([str(sum(row)) for row in b_matrix_in[0]])


# Call all functions and print matrices as needed
matrix_a, matrix_b = query_matrix('A', 0), query_matrix('B', 1)
ab_kronecker = kronecker_matrix(matrix_a, matrix_b)
trans_kronecker = transpose_matrix(ab_kronecker)
print('Random matrix A')
print_matrix(matrix_a[0])
print('Random matrix B')
print_matrix(matrix_b[0])
print('Matrix C:')
print_matrix(ab_kronecker[0])
print('Transpose matrix T:')
print_matrix(trans_kronecker[0])
print(f'Barcode String:')
print(matrix_barcode(trans_kronecker))

"""
Iteration 2: This is the flattened code I created after submitting the assignment. It is intentionally unreadable.
"""


def define_matrix_flat(dmr, dmc, dmmt):
    if not (0 < dmr < 11 and 0 < dmc < 11):
        return False
    else:
        return [[ra.randrange(0, 100, 2) + dmmt for _ in range(dmc)] for _ in range(dmr)]


def query_matrix(qmmd, qmmt):
    qmd = [int(_) for _ in input(f'Enter matrix {qmmd} rows and columns: ').split(' ')]
    if not define_matrix_flat(qmd[0], qmd[1], qmmt):
        print('Invalid matrix size. Try again.')
        query_matrix(qmmd, qmmt)
    else:
        print()
        return [(define_matrix_flat(qmd[0], qmd[1], qmmt)), qmd[0], qmd[1]]


def print_matrix(pmpm):
    for _ in pmpm:
        for _ in _:
            print(f'{_:<6}', end='')
        else:
            print()
    else:
        print()


def kronecker_matrix(kmo, kmt):
    km = [[1 for _ in range(kmo[2] * kmt[2])] for _ in range(kmo[1] * kmt[1])]
    for ir, ic, br, bc in it.product(range(kmo[1]), range(kmo[2]), range(kmt[1]),
                                     range(kmt[2])):
        tr, tc = br + (ir * kmt[1]), bc + (ic * kmt[2])
        km[tr][tc] = kmo[0][ir][ic] * kmt[0][br][bc]
    return [km, (kmo[1] * kmt[1]), (kmo[2] * kmt[2])]


def transpose_matrix(tmi):
    tmt = [[0 for _ in range(tmi[1])] for _ in range(tmi[2])]
    for rt, c in it.product(range(tmi[1]), range(tmi[2])):
        tmt[c][rt] = tmi[0][rt][c]
    return [tmt, (tmi[2]), (tmi[1])]


def matrix_barcode(bm): return ' '.join([str(sum(_)) for _ in bm[0]])


matrix_a, matrix_b = query_matrix('A', 0), query_matrix('B', 1)
print(f'Random matrix A\n{print_matrix(matrix_a[0])}')
print(f'Random matrix B\n{print_matrix(matrix_b[0])}')
print(f'Matrix C:\n{print_matrix(kronecker_matrix(matrix_a, matrix_b)[0])}')
print(f'Transpose matrix T:\n{print_matrix(transpose_matrix(kronecker_matrix(matrix_a, matrix_b))[0])}')
print(f'Barcode String:\n{matrix_barcode(transpose_matrix(kronecker_matrix(matrix_a, matrix_b)))}')
